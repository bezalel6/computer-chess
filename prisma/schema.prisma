// Prisma schema for Computer Chess Next.js application
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model - supports both registered users and guests
model User {
  id            String    @id @default(cuid())
  username      String    @unique
  email         String?   @unique
  passwordHash  String?
  isGuest       Boolean   @default(false)

  // Progression stats
  totalXP       Int       @default(0)
  rank          Rank      @default(NOVICE)
  gamesPlayed   Int       @default(0)
  gamesWon      Int       @default(0)
  totalPoints   Int       @default(0)
  challengesCompleted Int @default(0)
  longestStreak Int       @default(0)
  bestCombo     Int       @default(0)

  // Relations
  gamesAsWhite  Game[]    @relation("WhitePlayer")
  gamesAsBlack  Game[]    @relation("BlackPlayer")
  challenges    ChallengeResult[]
  sessions      Session[]
  accounts      Account[]

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([username])
  @@index([email])
  @@index([rank])
  @@index([totalXP])
}

// NextAuth Account model
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

// NextAuth Session model
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// NextAuth VerificationToken model
model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Game model - represents a chess game between two players
model Game {
  id              String      @id @default(cuid())
  whitePlayerId   String
  blackPlayerId   String
  whitePlayer     User        @relation("WhitePlayer", fields: [whitePlayerId], references: [id])
  blackPlayer     User        @relation("BlackPlayer", fields: [blackPlayerId], references: [id])

  status          GameStatus  @default(IN_PROGRESS)
  result          GameResult?
  winnerId        String?

  // AI game fields
  isAIGame        Boolean     @default(false)
  aiDifficulty    AIDifficulty?
  playerColor     String?     // 'white' or 'black' for AI games

  initialFen      String      @default("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1")
  currentFen      String
  moves           Move[]

  whiteScore      Int         @default(0)
  blackScore      Int         @default(0)
  whiteXpEarned   Int         @default(0)
  blackXpEarned   Int         @default(0)
  whiteLongestStreak Int      @default(0)
  blackLongestStreak Int      @default(0)
  whiteChallengesCompleted Int @default(0)
  blackChallengesCompleted Int @default(0)

  challengeCompletions ChallengeCompletion[]
  gameResult      GameResult_V2?

  startedAt       DateTime    @default(now())
  endedAt         DateTime?
  lastActivityAt  DateTime    @default(now())

  @@index([whitePlayerId])
  @@index([blackPlayerId])
  @@index([status])
  @@index([lastActivityAt])
  @@index([isAIGame])
}

// Move model - represents a single chess move in a game
model Move {
  id              String      @id @default(cuid())
  gameId          String
  game            Game        @relation(fields: [gameId], references: [id], onDelete: Cascade)

  moveNumber      Int
  from            String      // e.g., "e2"
  to              String      // e.g., "e4"
  promotion       String?     // e.g., "q" for queen

  fenAfterMove    String
  evaluationCp    Int?        // Stockfish evaluation in centipawns

  createdAt       DateTime    @default(now())

  @@index([gameId, moveNumber])
}

// Challenge model - predefined challenge types
model Challenge {
  id              String            @id @default(cuid())
  name            String
  description     String
  challengeType   ChallengeType

  results         ChallengeResult[]

  createdAt       DateTime          @default(now())

  @@index([challengeType])
}

// ChallengeResult model - tracks challenge attempts by users in games
model ChallengeResult {
  id              String            @id @default(cuid())
  gameId          String
  challengeId     String
  challenge       Challenge         @relation(fields: [challengeId], references: [id])
  userId          String
  user            User              @relation(fields: [userId], references: [id])

  status          ChallengeStatus
  pointsAwarded   Int
  moveNumber      Int

  createdAt       DateTime          @default(now())

  @@index([gameId])
  @@index([userId])
  @@index([challengeId])
}

// ChallengeCompletion model - detailed per-turn challenge tracking
model ChallengeCompletion {
  id                String          @id @default(cuid())
  gameId            String
  game              Game            @relation(fields: [gameId], references: [id], onDelete: Cascade)

  playerId          String
  moveNumber        Int

  challengeName     String
  challengeType     String
  difficulty        Difficulty

  completed         Boolean
  pointsAwarded     Int             @default(0)
  streakCount       Int             @default(0)
  comboSize         Int             @default(0)

  createdAt         DateTime        @default(now())

  @@index([gameId])
  @@index([playerId])
  @@index([moveNumber])
}

// GameResult_V2 model - comprehensive end-of-game stats
model GameResult_V2 {
  id                        String   @id @default(cuid())
  gameId                    String   @unique
  game                      Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)

  winnerId                  String?

  // White player stats
  whitePoints               Int      @default(0)
  whiteXP                   Int      @default(0)
  whiteChallengesPresented  Int      @default(0)
  whiteChallengesCompleted  Int      @default(0)
  whiteLongestStreak        Int      @default(0)
  whiteBestCombo            Int      @default(0)
  whiteCompletionRate       Float    @default(0)

  // Black player stats
  blackPoints               Int      @default(0)
  blackXP                   Int      @default(0)
  blackChallengesPresented  Int      @default(0)
  blackChallengesCompleted  Int      @default(0)
  blackLongestStreak        Int      @default(0)
  blackBestCombo            Int      @default(0)
  blackCompletionRate       Float    @default(0)

  createdAt                 DateTime @default(now())

  @@index([winnerId])
  @@index([whitePoints])
  @@index([blackPoints])
}

// MatchQueue model - manages matchmaking queue
model MatchQueue {
  id              String      @id @default(cuid())
  userId          String      @unique

  createdAt       DateTime    @default(now())
  expiresAt       DateTime

  @@index([expiresAt])
}

// PendingChallenge model - friend challenges awaiting acceptance
model PendingChallenge {
  id              String      @id @default(cuid())
  challengerId    String
  challengedId    String
  challengerColor String      // "white" or "black" - chosen by challenger

  status          PendingChallengeStatus @default(PENDING)
  gameId          String?

  createdAt       DateTime    @default(now())
  expiresAt       DateTime

  @@index([challengedId, status])
  @@index([challengerId])
  @@index([expiresAt])
}

// Enums
enum GameStatus {
  WAITING
  IN_PROGRESS
  COMPLETED
  ABANDONED
}

enum GameResult {
  WHITE_WIN
  BLACK_WIN
  DRAW
  ABANDONED
}

enum ChallengeType {
  BEST_MOVE
  WORST_MOVE
  BEST_KNIGHT_MOVE
}

enum ChallengeStatus {
  POSSIBLE
  SUCCESS
  FAIL
}

enum PendingChallengeStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}

enum Rank {
  NOVICE
  AMATEUR
  CLUB_PLAYER
  EXPERT
  CANDIDATE_MASTER
  MASTER
  GRANDMASTER
  WORLD_CLASS
}

enum Difficulty {
  EASY
  MEDIUM
  HARD
  EXPERT
}

enum AIDifficulty {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  MASTER
}